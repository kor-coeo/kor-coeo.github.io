<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Thymeleaf]]></title>
    <url>%2F2019%2F07%2F31%2Fpost-11%2F</url>
    <content type="text"><![CDATA[引入&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 标签 th:text=”${description}” 表达式语法 变量表达式： ${…} 选择变量表达式： *{…} 信息表达式： #{…} 链接 URL 表达式： @{…} 分段表达式： ~{…}字面量 字符串： ‘one text’ 数字： 0, 34, 3.0 布尔值： true, false Null 值： null 字面量标记：one, sometext文本运算 字符串拼接： + 字面量置换: |The name is ${name}|比较运算 比较： &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 相等运算符： ==, != (eq, ne)特殊语法 无操作： _]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot]]></title>
    <url>%2F2019%2F07%2F25%2Fpost-10%2F</url>
    <content type="text"><![CDATA[概要 习惯优先于配置 (前后端分离，可无视) 内嵌 Servlet 容器：Tomcat 、 Jetty 前后端分离 前端 &lt;– 跳转逻辑和页面交互 后端 只负责提供接口数据 RESTful api 前端工作更重，除非后端有复杂的算法设计 主要是易扩展 前后端可独立出来，中间是一般的 RESTful 交流。前端可选框架更多，VUE等，脱离Java，可使用 Nginx。 Maven mvn 类似 –&gt; npm编译、依赖、打包、运行、文档 AJAX Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） 编程方法、标准、设计模式 RESTful apiRepresentational State Transfer 基本原则 URI，Universal Resource Identifier 尽量 全小写 尽量 不用 动词 集合 用 复数形式 HTTP 协议 动词 GET，获取 POST，新建 PUT，更新 完整的 PATCH，更新 部分属性 DELETE，删除资源 状态码 200 成功 401 无权限（用户行为错误） 5xx 服务器错误（拥塞..） 安全原则 Authentication 和 Permission 常用的认证机制是 Basic Auth 和 OAuth CORS，Cross-origin resource sharing 注解 @responseBody，将返回结果转化为 JSON or XML 后，填充到目标 body @Param，简化 MyBatis 中 mapper.xml 的配置 事务 &amp; AOP声明式事务： xml @Transactional（其他：编程式事务）声明式事务是建立在 AOP 机制之上的，其本质是 **对方法前后进行拦截** 其他组件Redis日志型、Key-Value数据库 @Scheduled 实现定时任务入口 Application 需添加 @EnableScheduling SwaggerRESTful API文档、接口测试 @ApiOperation @ApiImplicitParams @ApiImplicitParamSpring Boot Admin资源、性能监控 @EnableAdminServer spring.boot.admin.client.url=http://localhost:port 目录结构（开发结构）entityDao 数据连接对象@Repository（一般不用，有xml） dao接口包 mapper 中基于 Mybatis 的 xml 对象（beans） Service 层@service 当项目的业务逻辑简单时，可选择service层=service类； 当项目的业务复杂时，可选择service层=service接口+serviceImpl实现类； Controller 层@Controller or @RestController（包含 @ResponseBody） @component普通的、一般的 Bean，如 定时任务 自定义路径映射SpringBootWebMvcConfigurerregistry.addResourceHandler(&quot;/files/**&quot;).addResourceLocations(&quot;file:/home/user/folder/&quot;); 项目配置application.properties 日志 logging.level.pkg.pkg=level logging.path/logging.file http服务 server.port=8082 spring.resources.static-locations=classpath:/folderA/,classpath:/folderB/ server.servlet.context-path=/shiyanlou/ 文件上传 MultipartResolver spring.servlet.multipart.max-file-size 数据库相关 mybatis.mapper-locations=classpath:mapper/*Dao.xml]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring poi >_]]></title>
    <url>%2F2019%2F07%2F22%2Fpost-9%2F</url>
    <content type="text"><![CDATA[Terms 依赖注入（DI，Dependency Injection）依赖注入是控制反转的一个具体的例子。 控制反转（IoC，Inversion of Control） 面向切片的程序设计（AOP，Aspect Oriented Programming）在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。 ORM，Object Relational Mapping OXM，Object XML Mapping JPA，Java Persistence API，Java持久层API JSP，Java Server Pages or Servlet CGI，Common Gateway Interface，通用网关接口 POJO，Plain Ordinary Java Object，平滑简单的Java对象，一般只有一些属性和get、set、is方法，没有复杂的业务逻辑、方法，有时可以作为VO(value -object)或DTO(Data Transform Object)来使用 PO，Persistent Object，持久对象 DAO，Data Access Object，数据访问对象 Spring Beans写在xml文件里,get、set必须和属性对应 三种获得途径 本地绝对路径，FileSystemXmlApplicationContext CLASSPATH，ClassPathXmlApplicationContext Web路径，WebXmlApplicationContext 作用域 Scopes singleton 单例 prototype 原型，即不是单例 其他，Web相关：request，session，global-session 生命周期 Life Cycle 可选 init-method or destroy-method Bean 后置处理器 允许在调用 初始化方法 前后 对 Bean 进行额外的处理。 继承 or 模板 abstract=”true” parent=”beanTeamplate” 依赖注入 DI constructor-arg property12345678910111213141516一般， new Obj：public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor() &#123; spellChecker = new SpellChecker(); &#125;&#125;IoC， 传参：public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125;&#125;ps： 问题场景 --&gt; 依赖类 构造方法带参数 or 可变。非 IoC 需要在自身内部变动。 基于构造函数 &lt;constructor-arg ref=&quot;spellChecker&quot;/&gt; 多个参数，按序或者指定index value：传值（基本类型），ref：引用（对象） 基于 setter &lt;property name=&quot;spellChecker&quot; ref=&quot;spellChecker&quot;/&gt; 严格要有一个 setObjxxx(…) 方法ps: &lt;property name=&quot;..&quot; (value or ref)=&quot;..&quot;/&gt; 可简写为 p:..=&quot;..&quot; or p:..-ref=&quot;..&quot; value Of 集合： list set map props 自动装配 autowire byName byType constructor (对构造函数基于 参数 Type 匹配) autodetect (constructor –&gt; byType)ps：一般都是单例，一个类型只有一个，故可以 byType。针对非基本类型，即引用（bean）。 注解 初级 @Required 针对 setter 方法。可不写，编译时提示性作用，提示要xml。 @Autowired byType，针对整个类（bean）or 方法、属性。即 都可以。必须，如果 不写xml 的话。 @Qualifier 辅助 Autowired，有多个相同 Type 的 Bean 的生活。ps：@Autowired(required=false) 允许为 null 其他 @PostConstruct @PreDestroy 替代 xml 中的 init-method、destroy-method @Resource(name= “…”) byName，可以替代xml，（..）可省略、自动获取 高级，针对 Bean 的注解 @Configuration 修饰 类，指明该类是 Bean 的生成工厂（配置区域、定义来源、上下文、同xml）。 @Bean 修饰方法，该方法会返回一个 Bean（属性设置完毕，准备就绪的Obj），其 id 为 方法名。 @Import 导入 别的 @Configuration 上下文。ps：这样配置下的 Bean 相互依赖的话，不用进行额外的设置。 事件 Event of Context捕获和处理：class BeanExp implements ApplicationListener&lt;...Event&gt;一般有：ContextRefreshedEvent ContextStartedEvent ContextStoppedEvent ContextClosedEvent RequestHandledEvent 自定义事件12345671. 定义 Event：public class CustomEvent extends ApplicationEvent2. 发布 Event：implements ApplicationEventPublisherAware;ApplicationEventPublisher publisher;publisher.publishEvent(CustomEventObj); AOP在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。Spring AOP 模块提供 拦截器 来拦截一个应用程序。 Spring JDBCMapper事物 ACID 原子 一致 隔离 持久 Spring MVC@Controller 指定一个 类 是 控制器 @RequestMapping(URL) 修饰 类 or 方法。以 第一处 作 相对路径。-]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 开发笔记]]></title>
    <url>%2F2019%2F07%2F11%2Fpost-8%2F</url>
    <content type="text"><![CDATA[概念 serializable 序列化 使实例对象可存储、永久存在，方便恢复和复用]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 核心技术 (◔౪◔)]]></title>
    <url>%2F2019%2F07%2F10%2Fpost-7%2F</url>
    <content type="text"><![CDATA[继承、接口、多态继承 super父类引用 super（）父类构造方法 equals（Object类方法）默认使用 == 需重写（覆盖） 重载 函数名相同，参数不同 向上转型（安全） 向下转型（先确认类型，然后显式转换，instanceof） 不定长参数方法: type fun(type…arg) == fun(type[] args) 接口 关键字 interface 纯粹的抽象类 对比多态（抽象方法） 父类可不抽象，部分子类可不实现 方法只能为 public abstract, 故省略 类的高级方法 类包 final方法 不可重写 final类 不能被继承 内部类 局部类 匿名类 异常处理try catch finally 反射Object类的一些方法 getName() 获得类的名称(是个String) getInterfaces() 获得接口 Class对象数组 getClass() Class对象 getConstructors() 为public的构造函数数组 用途：获得类的类型、成员变量、方法（可以是私密的） 多线程、网络通信、数据库操作]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从〇开始的Java学习]]></title>
    <url>%2F2019%2F07%2F09%2Fpost-6%2F</url>
    <content type="text"><![CDATA[Java 语言基础 pubilc static void main (String[] args){} final 定义时赋初始值 类名.静态变量 浮点类型： float 12.25f（默认为double，所以要加f or F）（double 可选加D、d） boolean 整数 负数的第一位为1，补码 变量范围，所在 { } 内？static，往外一层？ 运算符 赋值 = ⬅ ＝ ⬅ 逻辑运算：与 （&amp;&amp; 先判断左边的 or &amp; ） 或 （||） 非 （！） 位运算 与&amp; 或| 取反~ 异^（指数运算得用函数） 移位 &lt;&lt;（补0） &gt;&gt;(第一位为1则补1) &gt;&gt;&gt;（都补0） 三元运算符 条件式？true：false； 显式（强制）类型转换 int a = (int)45. 注释与编码规范注释 //单行 / / /* / 文档注释 Javadoc 规范 命令要 ； 结尾 流程控制可以利用{}创建局部变量作用域 if1234567if()&#123; ...&#125; else if()&#123; ...&#125; else &#123; ...&#125; 单句可省略{} switch可为字符串类型 while for | foreach 指 for（ x; arr)字符串String str (未初始化 == null) 连接： String s = strA + “ “ + strB + oneInt; == 比较的是地址， str.equals(otherStr) 创建的字符串，内容不可修改（频繁申请和销毁内存空间) 易变： StringBuffer（线程安全） 和 StringBuilder（快） 格式化12345String fs;fs = String.format(&quot;浮点型变量的值为 &quot; + &quot;%f, 整型变量的值为 &quot; + &quot; %d, 字符串变量的值为 &quot; + &quot; %s&quot;, floatVar, intVar, stringVar); 正则12String regex=&quot;.....&quot;;str.matches(regex); 数组123456789int arrA[] = new int[]&#123;1,2.3&#125;;int arrB[] = &#123;1,1,2,2&#125;;int arrC[][] = new int[2][4];int arrD[][] = new int[2][];arrD[0] = new int[2];arrD[1] = new int[3];int arrE[][] = new int[][]&#123;&#123;1&#125;,&#123;2,3&#125;,&#123;4,5,6&#125;&#125;; 面向对象 类 实例化 —&gt; 对象 封装、继承、多态（使用父类方法、抽象函数、c++虚函数、可用接口替代） 类先写变量 后方法（定义和声明不分开） this 引用 静态方法不可使用this以及调用非静态方法 Java只能有静态类成员变量，没有方法中的静态局部变量 static{} 类初始化的 静态区域]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 配置]]></title>
    <url>%2F2019%2F04%2F21%2Fpost-5%2F</url>
    <content type="text"><![CDATA[……好吧，有现成的。指路 –&gt; vimplus]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置]]></title>
    <url>%2F2019%2F04%2F19%2Fpost-4%2F</url>
    <content type="text"><![CDATA[安装sudo apt-get updatesudo apt-get install nginx 防火墙查看可用脚本sudo ufw app list允许 80 和 443 端口sudo ufw allow &#39;Nginx Full&#39;开机启动防火墙sudo ufw enable systemctl 控制1234sudo systemctl status nginxsudo systemctl stop nginxsudo systemctl start nginxsudo systemctl restart nginx 文件配置Nginx配置目录: /etc/nginx 站点响应 添加 /etc/nginx/sites-available/example.com 12345678910111213server &#123; listen 80; listen [::]:80; root /.../.../example; index index.html index.htm index.nginx-debian.html; server_name example.com www.example.com; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 链接sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ 日志/var/log/nginx]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt -- 利用 SDK 进行交叉编译]]></title>
    <url>%2F2019%2F04%2F17%2Fpost-3%2F</url>
    <content type="text"><![CDATA[安装SDK 到OpenWrt官网下载对应的SDK包：https://downloads.openwrt.org/releases/17.01.4/targets/x86/64/ 文件名大概长这样：lede-sdk-17.01.4-x86-64_gcc-5.4.0_musl-1.1.16.Linux-x86_64.tar.xz 解压到合适的地方，配置环境变量： 123export OWRT=/home/coeo/IDE/openwrt-sdk/staging_dir/toolchain-x86_64_gcc-5.4.0_musl-1.1.16/binexport STAGING_DIR=/home/coeo/IDE/openwrt-sdk/staging_direxport PATH=$OWRT:$PATH 检查是否配置成功： 123source ~/.zshrc然后应该可以自动补全：x86_64-openwrt-linux-gcc 编译直接编译成可执行文件，然后使用scp上传至路由器。 环境依赖123sudo apt install subversion g++ zlib1g-dev build-essential git python timesudo apt install libncurses5-dev gawk gettext unzip file libssl-dev wgetsudo apt install libelf-dev 添加函数库如果有用到函数库，需要注意SDK是否支持对应的库。比如下面会用到libpcap和mysql，但是SDK里并没有预装。到SDK根目录下： 更新包目录(要先把上面的依赖装好)./scripts/feeds update -a 安装指定包（仅含配置文件）./scripts/feeds install libpcap./scripts/feeds install mysql-server 编译包make package/libpcap/compilemake package/mysql/compile Makefile123456789101112131415161718192021222324252627OBJS = rls.o main.oTAR = o.oCC = x86_64-openwrt-linux-gccTOPDIR = /home/coeo/IDE/openwrt-sdkLDFLAGS += -L$(TOPDIR)/staging_dir/target-x86_64_musl-1.1.16/usr/lib/LDFLAGS += -L$(TOPDIR)/staging_dir/target-x86_64_musl-1.1.16/usr/lib/mysql/LIBS += -lmysqlclient -lpthread -lz -lm -lrt -latomic -ldl -lpcapCFLAGS += -I$(TOPDIR)/staging_dir/target-x86_64_musl-1.1.16/usr/include/CFLAGS += -I$(TOPDIR)/staging_dir/target-x86_64_musl-1.1.16/usr/include/mysql/CFLAGS += -I$(TOPDIR)/staging_dir/target-x86_64_musl-1.1.16/usr/include/pcap/$(TAR) : $(OBJS) $(CC) $(CFLAGS) $(LDFLAGS) $(LIBS) $(OBJS) -o $(TAR)main.o : Main.c $(CC) $(CFLAGS) $(LDFLAGS) $(LIBS) -c Main.c -o main.orls.o : ReLitSniffer.h ReLitSniffer.c $(CC) $(CFLAGS) $(LDFLAGS) $(LIBS) -c ReLitSniffer.c -o rls.o.PHONY : cleanclean : rm $(TAR) $(OBJS) VMWare 安装 OpenWrt原文由于原版的镜像比较小，可能会有进行扩展的需要 准备一个Ubuntu 虚拟机 挂载到Ubuntu虚拟机（IDE格式），并扩展到所需的大小 使用fdisk -l找到挂载过来的磁盘 比如是/dev/sda，然后就用fdisk /dev/sda 12345678910p(记住第二个分区的起点)d(删除节点)2n(新建)p(分区类型：主分区)2原来分区的起点分区终点(默认)nw umount /dev/sda2 e2fsck -f /dev/sda2 resize2fs /dev/sda2]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 运维]]></title>
    <url>%2F2019%2F03%2F17%2Fpost-2%2F</url>
    <content type="text"><![CDATA[Mysql备份和恢复12345mysqldump -uroot -p -P3306 --databases ikazuchi &gt; ika.sqlmysqldump -uroot -p -P3306 ikazuchi table &gt; table.sqlmysql -uroot -p ikazuchi &lt; ika.sql CURD INSERTINSERT INTO ripe ( id, tag) VALUES ( %s, %s) UPDATEUPDATE ripe SET ta = %s WHERE id = %s SELECTSELECT MAX(tv_sec) FROM ripe WHERE … DELETEDELETE FROM ripe WHERE … 判断是否为 NULLIS NULLIS NOT NULL 设置为 NULLcol = NULL 将一个表的数据插入另一个表INSERT INTO tableA ( colA, colB) SELECT colA, colB FROM tableB WHERE … 查询某一列的取值select distinct col from table]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记 一个强迫症患者 对 重装系统 的 执着]]></title>
    <url>%2F2019%2F03%2F10%2Fpost-1%2F</url>
    <content type="text"><![CDATA[配置开发环境gcc g++ libpcap java ipython zsh onmyzsh 开发工具vim atom git workbench Python包scapy matplotlib pymysql 软件工具rime mozcchrome梯子wireshark 主题配置gnome-tweak-toolnumix-gtk-themedockdynamic-top-barfreon 快捷方式sudo ln -sT /home/user_name/folder/ /home/user_name/desktop/folder 一些有趣的命令1234567cmatrix -b -Ccyanfactorfor i in &#123;1..5&#125;;do echo `fortune`|cowsay|lolcat;donefuck 挂起、后台执行alias ecp=’nohup /home/coeo/IDE/eclipse/eclipse &amp;’ 备份12345sudo sucd /tar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz \--exclude=/mnt --exclude=/sys --exclude=/media / c - 新建一个文档v - 详细模式， tar程序将在屏幕上实时输出所有信息p - 保存许可，并应用到所有文件z - 采用‘gzip’压缩备份文件，以减小备份文件体积f - 说明备份文件存放的路径，backup.tgz “/“ 是我们要备份的目录，在这里是整个文件系统 在备份命令结束时可能会看到这样一个提示：’tar: Error exit delayed from previous errors’，多数情况下可以忽略 还原如果原来的Ubuntu系统已经崩溃，无法进入。则可以使用Ubuntu安装U盘（live USB）进入试用Ubuntu界面。切换到root用户，找到之前Ubuntu系统的根目录所在磁盘分区，一般为/dev/sdaX。1234567891011121314先把它挂载出来：sudo mount /dev/sdaX /mnt/sdaX删除该根目录下的所有文件：sudo rm -rf /mnt/sdaX将备份文件”backup.tgz”拷入该分区：sudo cp backup.tgz /mnt/sdaX进入分区并将压缩文件解压缩，参数x是告诉tar程序解压文件。sudo tar xvpfz backup.tgz重新创建那些在备份时被排除在外的目录：sudo mkdir proc lost+found mnt sys media 重启 &gt;_]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ありがとう - 东方歴絵巻(幽闭サテライト×白狐茶会)]]></title>
    <url>%2F2019%2F02%2F19%2Fpost%2F</url>
    <content type="text"><![CDATA[この目で計れない霞む過去や未来は触れられぬ事実となり、また幻になるだろう神などいるのでしょうか信じてみたけれど都合良いものじゃないとつい忘れてしまった 亡き者を想えば悲しいのだけど安心できる見返りなどいらぬそんな矛盾 愛の歴史 行く当てなどないでしょうそれでも 無意味では無い「ありがとう」 この身体生まれてきたよ優しい気持ちはすぐに忘れがちだけれども「ありがとう」 この気持ち心に刻んだよ 善人にはなれぬ気付いたのさ いつしかできるだけ清々しい生き方で良い気がする 行く当てなどないでしょうそれでも 無意味では無い「ありがとう」 この身体生まれてきたよ優しい気持ちはすぐに忘れがちだけれども「ありがとう」 この気持ち忘れたくない貴方を想うと心が洗われてゆく「ありがとう、おやすみ」この足で歩くよ]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>音乐</tag>
        <tag>东方</tag>
      </tags>
  </entry>
</search>
